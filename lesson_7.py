# ЗАДАЧА
# Необходимо создать функцию sumNumbers(n), которая будет
# считать сумму всех элементов от 1 до n.
# Решение:
# 1. Необходимо создать функцию:
# def sumNumbers(n):
# Очень важно понимать одну вещь, сколько аргументов мы передаем,
# столько и принимаем. Или наоборот сколько аргументов мы
# принимаем, столько и передаем.
# В нашем случае функция sumNumbers принимает 1 аргумент(n).
# принимает 1 аргумент(n).

def sumNumbers(n):
    summa = 0
    for i in range(1, n + 1):
        summa += i
    print(summa)

sumNumbers(5)


# Переделываем код, чтобы фукнция возвращала значение

def sumNumbers(n):
    summa = 0
    for i in range(1, n + 1):
        summa += i
    return summa                        # "return" - завершает работу фукнции. Код, написаннай послле него, выполнятся не будет.
    print('stop')                       # код выделен приглушенными красками, так как он не будет выполнен (т.к. идет после return)

print(sumNumbers(5))


# Вводим в фукцию переменную

def sumNumbers(n):
    summa = 0
    for i in range(1, n + 1):
        summa += i
    return summa

a = sumNumbers(5)
print(a)


# ЗАДАЧА 2
# Мы хотим составить из букв слово, но не знаем точно, сколько букв будем передавать
# Тогда напишим фукцию, которая будет принимать неограниченное количесво аргументов:

def sum_str(*args):             # создали ф-цию с названием sum_str с переменной args. Значек * говорит, что будем передавать неограниченное количесво
    res = ''                    # создали переменную res с типом данных строка
    for i in args:              
        res += i
    return res

print(sum_str('h','e','l','l','o','y'))
print(sum_str('d ','e ','l'))

# ---------------------------------------------------------------------------------------------------

# РАБОТА С МОДУЛЯМИ

import modul1                     # импорт модуля из файлам modul1 
print(modul1.max1(5, 9))          # обращение к ф-ции max1 в файле modul1, и передача двух значений для поиска максимума, и вывод через print
     

# можем обратиться к модулю с функциями по другому

from modul1 import max1
print(max1(5, 9))


# если не хотим перечислять все импортируемы функции через зяпятую, то можем имортировать все через '*'

from modul1 import *
print(modul1.max1(5, 9))


# если не хочется писать длинное имя файла с модулями, то можно его сократить в рамках алгоритма через 'as'

import modul1 as m1
print(m1.max1(5, 9))

# ---------------------------------------------------------------------------------------------------

# РЕКУРСИЯ 
# - это функция, вызывающая сама себя. При описании рекурсии важно указать, 
# когда функции надо остановиться и перестать вызывать саму себя. 
# По-другому говоря, необходимо указать базис рекурсии

# Задача
# Пользователь вводит число n. Необходимо вывести n - первых членов последовательности Фибоначчи.
# Напоминание: Последовательно Фибоначчи, это такая последовательность, в
# которой каждое последующее число равно сумму 2-ух предыдущих.

# Внутри функции fib(n), мы сначала задаем базис, если число n равно 1 или 2, это означает, что первое число и
# второе число последовательности равны 1. Мы так и делаем возвращаем 1. Как мы ранее проговорили:
# “Последовательно Фибоначчи, это такая последовательность, в которой каждое последующее число
# равно сумму 2-ух предыдущих”. Так и делаем, складываем на 2 предыдущих числа друг с другом и получаем 3.

def fib(n):
    if n in [1, 2]:                   # обязательно нужен базис, т.е. условие, когда рекурсия остановится (чтобы выйти из цикла)
        return 1                      # прерываения выполнения условия через return, чтобы ф-я работала корректно
    return fib(n - 1) + fib(n - 2)    # затем идет функция, универсальная для остальных значений

list_1 = []
for i in range(1, 10):
    list_1.append(fib(i))       # в этой строке вызываем рекурсию   
print(list_1)                   # [1, 1, 2, 3, 5, 8, 13, 21, 34]

# ---------------------------------------------------------------------------------------------------

# АЛГОРИТМЫ
#  Алгоритмом называется набор инструкций для выполнения некоторой задачи. В принципе, любой фрагмент
# программного кода можно назвать алгоритмом, но мы с Вами рассмотрим 2 самых интересных алгоритмы сортировок:
# ● Быстрая сортировка
# ● Сортировка слиянием

# БЫСТРАЯ СОРТИРОВКА (quicksort)

# Задача
# Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать.
# Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60,
# 73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй
# и властвуй” Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр,
# который отгадывает. Итак начнем:

def quicksort(array):                             # вызываем ф-цию quicksort (она уже работает по определенному алгоритму) и говорим, что передаем в не массив array
    if len(array) <=  1:                            # сразу делаем проверку, если длина массива <= 1, 
        return array                                # то возращаем сам массив, т.е. мы создали базис рекурсии (см.строку 102-104 с комментариями)
    else:                                          
        pivot = array[0]                                 
        less = [i for i in array[1:] if i <= pivot]     #  будем собирать массим со значениями меньше задуманного, первый элемент не берем, т.к. учли в строке выше
        greater = [i for i in array[1:] if i > pivot]        #  будем собирать массим со значениями больше задуманного
        return quicksort(less) + [pivot] + quicksort(greater)  # при возврате тажке будем сортировать значения в новых массивах less и graeter
print(quicksort([10, 5, 2, 3]))


# СОРТИРОВКА СЛИЯНИЯ (merge_sort)

def merge_sort(nums):
    if len(nums) > 1:
        mid = len(nums) // 2                # делим список на две части путем деления длины списка на 2 без остатка, т.е. получаем "середину"
        left = nums[:mid]                   # получаем список от начала до "середиы" от исходного
        right = nums[mid:]                  # получаем список от "середиы" до конца от исходного
        merge_sort(left)                    # делим полученный список left пополам до конца с помощью merge_sort
        merge_sort(right)                   # делим полученный список right пополам до конца с помощью merge_sort
        i = j = k = 0
        while i < len(left) and j < len(right):   
            if left[i] < right[j]:
                nums[k] = left[i]
                i += 1
            else:
                nums[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            nums[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            nums[k] = right[j]
            j += 1
            k += 1
nums = [38, 27, 43, 3, 9, 82, 10]
merge_sort(nums)
print(nums)